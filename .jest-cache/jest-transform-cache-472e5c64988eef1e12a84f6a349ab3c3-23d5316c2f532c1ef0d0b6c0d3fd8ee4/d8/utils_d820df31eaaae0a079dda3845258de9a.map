{"file":"/workspace/src/utils.ts","mappings":"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","names":[],"sources":["/workspace/src/utils.ts"],"sourcesContent":["/**\n * Helper Functions for File Operations\n *\n * This file contains utility functions for file system operations,\n * path manipulation, and other common tasks used by the CLI\n */\n\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { FileSystemError, Assistant, TemplateFormat } from './types';\n\n/**\n * Create a directory recursively if it doesn't exist\n * @param dirPath - The directory path to create\n * @throws FileSystemError if directory creation fails\n */\nexport async function ensureDir(dirPath: string): Promise<void> {\n  try {\n    await fs.ensureDir(dirPath);\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to create directory: ${dirPath}`, {\n      originalError: errorMessage,\n      path: dirPath,\n    });\n  }\n}\n\n/**\n * Check if a directory exists\n * @param dirPath - The directory path to check\n * @returns Promise<boolean> - True if directory exists, false otherwise\n */\nexport async function directoryExists(dirPath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(dirPath);\n    return stats.isDirectory();\n  } catch (_error) {\n    // If file doesn't exist or any other error, return false\n    return false;\n  }\n}\n\n/**\n * Check if a file exists\n * @param filePath - The file path to check\n * @returns Promise<boolean> - True if file exists, false otherwise\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(filePath);\n    return stats.isFile();\n  } catch (_error) {\n    // If file doesn't exist or any other error, return false\n    return false;\n  }\n}\n\n/**\n * Check if a file or directory exists (generic)\n * @param filepath - The path to check\n * @returns Promise<boolean> - True if path exists, false otherwise\n */\nexport async function exists(filepath: string): Promise<boolean> {\n  try {\n    await fs.access(filepath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Copy a file or directory from source to destination\n * @param src - Source path (file or directory)\n * @param dest - Destination path\n * @param options - Copy options\n * @throws FileSystemError if copy operation fails\n */\nexport async function copyTemplate(\n  src: string,\n  dest: string,\n  options: { overwrite?: boolean } = { overwrite: true }\n): Promise<void> {\n  try {\n    await fs.copy(src, dest, options);\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to copy from ${src} to ${dest}`, {\n      originalError: errorMessage,\n      source: src,\n      destination: dest,\n    });\n  }\n}\n\n/**\n * Write JSON data to a file with proper formatting\n * @param filePath - The file path to write to\n * @param data - The data to write as JSON\n * @throws FileSystemError if write operation fails\n */\nexport async function writeJsonFile(filePath: string, data: unknown): Promise<void> {\n  try {\n    await fs.writeJson(filePath, data, { spaces: 2 });\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to write JSON file: ${filePath}`, {\n      originalError: errorMessage,\n      path: filePath,\n    });\n  }\n}\n\n/**\n * Read and parse a JSON file\n * @param filePath - The file path to read from\n * @returns The parsed JSON data\n * @throws FileSystemError if read operation fails\n */\nexport async function readJsonFile<T = unknown>(filePath: string): Promise<T> {\n  try {\n    return await fs.readJson(filePath);\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to read JSON file: ${filePath}`, {\n      originalError: errorMessage,\n      path: filePath,\n    });\n  }\n}\n\n/**\n * Parse comma-separated assistant values into an array\n * @param value - Comma-separated string of assistant names\n * @returns Array of assistant names\n * @throws Error if invalid assistant names are provided\n */\nexport function parseAssistants(value: string): Assistant[] {\n  const validAssistants: Assistant[] = ['claude', 'gemini'];\n\n  if (!value.trim()) {\n    throw new Error('Assistants parameter cannot be empty');\n  }\n\n  const assistants = value\n    .split(',')\n    .map(a => a.trim().toLowerCase())\n    .filter(a => a.length > 0);\n\n  // Validate that all assistants are valid\n  const invalidAssistants = assistants.filter(\n    (assistant): assistant is string => !validAssistants.includes(assistant as Assistant)\n  );\n\n  if (invalidAssistants.length > 0) {\n    throw new Error(\n      `Invalid assistant(s): ${invalidAssistants.join(', ')}. Valid options are: ${validAssistants.join(', ')}`\n    );\n  }\n\n  // Remove duplicates and return\n  return Array.from(new Set(assistants)) as Assistant[];\n}\n\n/**\n * Validate that all assistants are supported\n * @param assistants - Array of assistants to validate\n * @throws Error if any assistant is invalid or array is empty\n */\nexport function validateAssistants(assistants: Assistant[]): void {\n  const validAssistants: Assistant[] = ['claude', 'gemini'];\n\n  if (assistants.length === 0) {\n    throw new Error('At least one assistant must be specified');\n  }\n\n  for (const assistant of assistants) {\n    if (!validAssistants.includes(assistant)) {\n      throw new Error(\n        `Invalid assistant: ${assistant}. Supported assistants: ${validAssistants.join(', ')}`\n      );\n    }\n  }\n}\n\n/**\n * Get the absolute path for a given path, resolving it relative to the current working directory\n * @param inputPath - The input path (can be relative or absolute)\n * @returns The absolute path\n */\nexport function getAbsolutePath(inputPath: string): string {\n  return path.isAbsolute(inputPath) ? inputPath : path.resolve(process.cwd(), inputPath);\n}\n\n/**\n * Get the relative path from one path to another\n * @param from - The source path\n * @param to - The target path\n * @returns The relative path\n */\nexport function getRelativePath(from: string, to: string): string {\n  return path.relative(from, to);\n}\n\n/**\n * Join multiple path segments into a single path\n * @param segments - Path segments to join\n * @returns The joined path\n */\nexport function joinPath(...segments: string[]): string {\n  return path.join(...segments);\n}\n\n/**\n * Get the directory name from a file path\n * @param filePath - The file path\n * @returns The directory name\n */\nexport function getDirName(filePath: string): string {\n  return path.dirname(filePath);\n}\n\n/**\n * Get the base name (filename) from a file path\n * @param filePath - The file path\n * @param ext - Optional extension to remove\n * @returns The base name\n */\nexport function getBaseName(filePath: string, ext?: string): string {\n  return path.basename(filePath, ext);\n}\n\n/**\n * Get the file extension from a file path\n * @param filePath - The file path\n * @returns The file extension (including the dot)\n */\nexport function getExtension(filePath: string): string {\n  return path.extname(filePath);\n}\n\n/**\n * Get the template format for a specific assistant\n * @param assistant - The assistant type\n * @returns The template format to use ('md' for Claude, 'toml' for Gemini)\n */\nexport function getTemplateFormat(assistant: Assistant): TemplateFormat {\n  switch (assistant) {\n    case 'claude':\n      return 'md';\n    case 'gemini':\n      return 'toml';\n    default:\n      // This should never happen due to type safety, but adding for completeness\n      throw new Error(`Unknown assistant type: ${assistant}`);\n  }\n}\n\n/**\n * Get the absolute path to a template file\n * @param templateFile - The template filename\n * @returns The absolute path to the template\n */\nexport function getTemplatePath(templateFile: string): string {\n  return path.join(__dirname, '..', 'templates', templateFile);\n}\n\n/**\n * Get list of directories that will be created for given assistants\n * @param assistants - Array of assistants\n * @param baseDir - Base directory to resolve paths against (defaults to current directory)\n * @returns Array of directory paths to create\n */\nexport function getCreatedDirectories(assistants: Assistant[], baseDir?: string): string[] {\n  const base = baseDir || '.';\n  const dirs: string[] = [\n    resolvePath(base, '.ai/task-manager'),\n    resolvePath(base, '.ai/task-manager/plans'),\n  ];\n\n  for (const assistant of assistants) {\n    dirs.push(resolvePath(base, `.${assistant}`));\n    dirs.push(resolvePath(base, `.${assistant}/commands`));\n    dirs.push(resolvePath(base, `.${assistant}/commands/tasks`));\n  }\n\n  return dirs;\n}\n\n/**\n * Ensure a directory path ends with a path separator\n * @param dirPath - The directory path\n * @returns The directory path with trailing separator\n */\nexport function ensureTrailingSlash(dirPath: string): string {\n  return dirPath.endsWith(path.sep) ? dirPath : dirPath + path.sep;\n}\n\n/**\n * Create a safe filename by removing or replacing invalid characters\n * @param filename - The input filename\n * @returns A safe filename for the current platform\n */\nexport function sanitizeFilename(filename: string): string {\n  // Replace invalid characters with underscores\n  return filename\n    .replace(/[<>:\"/\\\\|?*]/g, '_')\n    .replace(/\\s+/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n}\n\n/**\n * Get the home directory path\n * @returns The user's home directory path\n */\nexport function getHomeDirectory(): string {\n  return require('os').homedir();\n}\n\n/**\n * Remove a file or directory recursively\n * @param targetPath - The path to remove\n * @throws FileSystemError if removal fails\n */\nexport async function remove(targetPath: string): Promise<void> {\n  try {\n    await fs.remove(targetPath);\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to remove: ${targetPath}`, {\n      originalError: errorMessage,\n      path: targetPath,\n    });\n  }\n}\n\n/**\n * Move a file or directory from source to destination\n * @param src - Source path\n * @param dest - Destination path\n * @throws FileSystemError if move operation fails\n */\nexport async function move(src: string, dest: string): Promise<void> {\n  try {\n    await fs.move(src, dest);\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to move from ${src} to ${dest}`, {\n      originalError: errorMessage,\n      source: src,\n      destination: dest,\n    });\n  }\n}\n\n/**\n * Resolve path segments relative to a base directory with cross-platform compatibility\n * @param baseDir - The base directory (defaults to '.' if not provided, null, or undefined)\n * @param segments - Additional path segments to resolve\n * @returns The resolved absolute path\n */\nexport function resolvePath(baseDir: string | undefined, ...segments: string[]): string {\n  // Handle edge cases: null, undefined, or empty strings\n  const base = baseDir || '.';\n\n  // Filter out any null, undefined, or empty string segments\n  const validSegments = segments.filter(\n    segment => segment !== null && segment !== undefined && segment !== ''\n  );\n\n  return path.resolve(base, ...validSegments);\n}\n\n/**\n * Interface for parsed markdown frontmatter\n */\nexport interface MarkdownFrontmatter {\n  [key: string]: unknown;\n}\n\n/**\n * Parse YAML frontmatter from markdown content\n * @param content - The markdown content with frontmatter\n * @returns Object containing frontmatter and body content\n */\nexport function parseFrontmatter(content: string): {\n  frontmatter: MarkdownFrontmatter;\n  body: string;\n} {\n  const frontmatterRegex = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---(?:\\r?\\n([\\s\\S]*))?$/;\n  const match = content.match(frontmatterRegex);\n\n  if (!match) {\n    return {\n      frontmatter: {},\n      body: content,\n    };\n  }\n\n  const frontmatterContent = match[1] || '';\n  const bodyContent = match[2] || ''; // match[2] is now undefined when no body exists\n\n  // Simple YAML parser for our specific use case\n  const frontmatter: MarkdownFrontmatter = {};\n  const lines = frontmatterContent.split('\\n');\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n\n    const colonIndex = trimmed.indexOf(':');\n    if (colonIndex === -1) continue;\n\n    const key = trimmed.substring(0, colonIndex).trim();\n    const value = trimmed.substring(colonIndex + 1).trim();\n\n    // Remove quotes if present\n    frontmatter[key] = value.replace(/^[\"']|[\"']$/g, '');\n  }\n\n  return {\n    frontmatter,\n    body: bodyContent,\n  };\n}\n\n/**\n * Escape a string for TOML format\n * @param str - The string to escape\n * @returns The escaped string suitable for TOML\n */\nexport function escapeTomlString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t');\n}\n\n/**\n * Convert markdown template content to TOML format for Gemini\n * @param mdContent - The markdown template content\n * @returns The converted TOML content\n */\nexport function convertMdToToml(mdContent: string): string {\n  const { frontmatter, body } = parseFrontmatter(mdContent);\n\n  // Process the body content for Gemini format\n  const processedBody = body\n    // Transform $ARGUMENTS → {{args}} (not followed by alphanumeric that would make it an identifier)\n    .replace(/\\$ARGUMENTS(?![0-9])/g, '{{args}}')\n    // Transform $1 → {{plan_id}} (exact match, not part of longer number)\n    .replace(/\\$1(?![0-9])/g, '{{plan_id}}')\n    .replace(/\\$2(?![0-9])/g, '{{param2}}')\n    .replace(/\\$3(?![0-9])/g, '{{param3}}');\n\n  // Build TOML content\n  let tomlContent = '[metadata]\\n';\n\n  // Add frontmatter fields to metadata section\n  for (const [key, value] of Object.entries(frontmatter)) {\n    if (key === 'argument-hint') {\n      // Special handling for argument-hint - convert to {{}} format\n      const convertedHint = String(value)\n        .replace(/\\[plan-ID\\]/g, '{{plan_id}}')\n        .replace(/\\[user-prompt\\]/g, '{{args}}');\n      tomlContent += `argument-hint = \"${escapeTomlString(convertedHint)}\"\\n`;\n    } else {\n      tomlContent += `${key} = \"${escapeTomlString(String(value))}\"\\n`;\n    }\n  }\n\n  // Add the prompt section with escaped content\n  tomlContent += '\\n[prompt]\\n';\n  tomlContent += `content = \"\"\"${escapeTomlString(processedBody)}\"\"\"\\n`;\n\n  return tomlContent;\n}\n\n/**\n * Read a markdown template file and optionally convert to TOML\n * @param templatePath - Path to the markdown template\n * @param targetFormat - Target format ('md' or 'toml')\n * @returns The template content in the requested format\n */\nexport async function readAndProcessTemplate(\n  templatePath: string,\n  targetFormat: TemplateFormat\n): Promise<string> {\n  try {\n    const mdContent = await fs.readFile(templatePath, 'utf-8');\n\n    if (targetFormat === 'md') {\n      return mdContent;\n    } else if (targetFormat === 'toml') {\n      return convertMdToToml(mdContent);\n    } else {\n      throw new Error(`Unsupported template format: ${targetFormat}`);\n    }\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to read and process template: ${templatePath}`, {\n      originalError: errorMessage,\n      path: templatePath,\n      targetFormat,\n    });\n  }\n}\n\n/**\n * Write processed template content to destination\n * @param content - The template content to write\n * @param destPath - Destination file path\n */\nexport async function writeProcessedTemplate(content: string, destPath: string): Promise<void> {\n  try {\n    // Ensure destination directory exists\n    await fs.ensureDir(path.dirname(destPath));\n\n    // Write the content\n    await fs.writeFile(destPath, content, 'utf-8');\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to write processed template: ${destPath}`, {\n      originalError: errorMessage,\n      path: destPath,\n    });\n  }\n}\n\n/**\n * Get the names of all markdown template files in a given subdirectory of templates.\n * @param templateSubdir - The subdirectory within templates (e.g., 'commands/tasks')\n * @returns An array of template names (filenames without .md extension)\n * @throws FileSystemError if the directory cannot be read\n */\nexport async function getMarkdownTemplateNames(templateSubdir: string): Promise<string[]> {\n  const fullPath = path.join(__dirname, '..', 'templates', templateSubdir);\n  try {\n    const files = await fs.readdir(fullPath);\n    return files.filter(file => file.endsWith('.md')).map(file => path.basename(file, '.md'));\n  } catch (_error) {\n    const errorMessage = _error instanceof Error ? _error.message : 'Unknown error';\n    throw new FileSystemError(`Failed to read template directory: ${fullPath}`, {\n      originalError: errorMessage,\n      path: fullPath,\n    });\n  }\n}\n"],"version":3}